// Задание №9 - Сортировка телефонной книги с выводом в файл

// Код не редактировался (кроме некоторых незначительных моментов) и выложен в том виде,
// в котором был написан в 2019 году при обучении в университете.

#include "stdafx.h" // 
#include "MyPhRecExB.h" // 
#include "Header.h" // подключение необходимых библиотек
#include <vector> // 
#include <iostream> // 
#include <fstream> // 
#include <string> // 
#include <conio.h> // 

using namespace std; // авто-использование пространства имен

int SearchNm(std::vector<CMyPhRecExB>& vecIn, char ch1); // объявление функции бинарного поиска

int main() // основной блок
{
	size_t R, R1; // объявление переменной
	char cA[80]; // объявление массива символов
	CLoc mLoc; // создание класса, в конструкторе которого включается ру локализация
	std::vector<CMyPhRecExB> vecIn; // создание вектора для работы с данными
	string filePath; // создание строки = путь к файлу с данными
	std::cout << "Пожалуйста, введитие путь к файлу:" << endl; // просьба ввести путь к файлу
	getline(cin, filePath); // ввод пути к файлу с данными
	std::cout << "Пожалуйста, введите количество записей в файле: "; // просьба ввести кол-во записей в файле
	cin >> R; // непосредственно ввод кол-ва записей в файле
	std::cout << "Пожалуйста, введите количество записей, которые будут вводится с клавиатуры: "; //
	cin >> R1; // непосредственно ввод кол-ва записей с клав-ы
	fstream filePh(filePath.c_str()); // создание потока
	for (size_t i = 0; i < R; i++) // цикл ввода данных из файла
	{
		if (filePh.is_open()) // если файл открыт, то 
		{
			CMyPhRecExB A; // создаем класс
			size_t iCol = 0; // инициализация счетчика
			string sA; // объявление строки-помощн
			cA[0] = '\0'; // обнуление массива символов
			while (getline(filePh, sA)) // перенос строки из файла в нашу строку-помощник
			{
				if (iCol == 0) // если счетчик равен нулю
				{
					strcpy_s(cA, sA.size() + 1, sA.c_str()); // перенос строки в переменную-помощник
					A.m_No = atoll(cA); // перенос строки с данными в переменную класса
				}
				if (iCol == 1) // если счетчик равен единице
					A.m_Nik = sA; // то перенести ник в переменную класса
				if (iCol == 2) // если счетчик равен двум
				{
					A.m_Addr = sA; // то перенести почту
					break; // выход из цикла
				}
				iCol++; // увеличение счетчика на единицу
			}
			vecIn.push_back(A); // добавление записей к вектору
		}
	}
	if (R1) // если нужно ввести хотя бы одну запись
		std::cout << "Ввод записей с клавиатуры: " << endl << endl; // то пишем об этом
	for (size_t i = 0; i < R1; i++) // цикл ввода записей с клавиатуры
	{
		CMyPhRecExB A; // создаем класс
		std::cout << "Номер телефона: "; // 
		cin >> A.m_No; // ввод номера телефона
		std::cout << "Имя: "; // 
		cin >> A.m_Nik; // ввод имени
		std::cout << "Емаил: "; // 
		cin >> A.m_Addr; // ввод емаила
		std::cout << endl; // 
		vecIn.push_back(A); // добавление записи к вектору
	}
	size_t nCmps_s = 0; // инициализация переменной для счета количества замен в нашем способе сортировки
	for (size_t iy = 0; iy < vecIn.size() - 1; iy++) // цикл сортировки
	{//buble sort
		size_t nCmps = 0; // инициализация переменной для помощи в счете коичества замен
		for (size_t i = vecIn.size() - 1; i > iy; i--) // цикл сравнения и замены при необходимости
		{
			if (vecIn[i].Compare(vecIn[i - 1])) // если сравнение и замена удалась
				nCmps++; // то счетчик +1
		}
		nCmps_s += nCmps; // переносим
		if (!nCmps) // если замен не произошло, то 
			break; // выход из цикла сортировки
	}
	filePath.replace(filePath.find("Phones"), 6, "Result"); // замена элементов
	fstream fileOut(filePath.c_str()); // создание потока для вывода данных в файл
	fileOut.open(filePath.c_str(), std::fstream::out); // открытие файла для вывода
	fileOut << "     Name    |    Phone    |        Mail          |          Bin " << endl; // часть пользовательского интерфейса
	fileOut << "----------------------------------------------------------------------------------------" << endl; // часть пользовательского интерфейса
	for (size_t i = 0; i < R + R1; i++) // цикл вывода данных из файла
	{
		size_t cT1 = vecIn[i].m_Nik.size(); // инициализация переменной, равной длинне строки имени
		size_t cT3 = vecIn[i].m_Addr.size(); // инициализация переменной, равной длине строки емаила
		int pom = 1; // инициализация переменной-счетчика, равной единице
		__int64 t = vecIn[i].m_No; // инициализация переменной, которая равна введённому номеру телефона
		while (t) // цикл поиска количества цифр в номере телефона, работает пока переменная не 0
		{
			t /= 10; // делим переменную на 10
			pom++; // увеличиваем счетчик на единицу
		}
		for (int i = 0; i <= 12 - cT1; i++) fileOut << " "; // выводим пробелы
		fileOut << vecIn[i].m_Nik << "|"; // после пробелов выводим имя и ставим |
		for (int i = 0; i <= 13 - pom; i++) fileOut << " "; // выводим пробелы
		fileOut << vecIn[i].m_No << "|"; // после пробелов выводим номер телефона и ставим |
		for (int i = 0; i <= 21 - cT3; i++) fileOut << " "; // выводим пробелы
		fileOut << vecIn[i].m_Addr << "|"; // после пробелов выводим емаил и ставим |
		unsigned __int64 mask = __int64(1) << 36; // инициализация переменной маски для перевода номера телефона в двоичный код
		while (mask) // пока маска не 0
		{
			if (vecIn[i].m_No & mask) // если побитовое логическое И не 0
				fileOut << "1"; // то выводим 1
			else fileOut << "0"; // иначе выводим 0
			mask = mask / 2; // делим маску на 2
		}
		fileOut << " " << endl; // выводим в конце пробел и переходим на следующую строку
	}
	fileOut << "----------------------------------------------------------------------------------------" << endl; // часть пользовательского интерфейса
	fileOut << "Kol-vo zamen: " << nCmps_s << endl; // вывод количества сравнений с заменой
	//prompt for search
	std::cout << "Пожалуйста, введите первую букву имени для поиска: "; // просьба ввести букву для поиска имени
	char chI = _getch(); // инициализация буквы, по которой ищем имя
	std::cout << endl; // переход на след. строку в консоли (для удобства)
	int nRet = SearchNm(vecIn, chI); // инициализация переменной, равной 
	if (nRet < 0) // если бинарный поиск не нашел что искали
		fileOut << chI << " - Not Found" << endl; // то "не найдено"
	else // если нашел
		fileOut << chI << " - Found: " << vecIn[nRet].m_No << endl; // то "найдено: " и вывод результата
	fileOut.close(); // закрытие файла для вывода
	std::system("pause"); // пауза выхода из консоли
	return 0; // возвращение нуля
}

int SearchNm(std::vector<CMyPhRecExB>& vecIn, char ch1) // функция бинарного поиска
{
	if (vecIn.size()) // если длина входного вектора не 0
	{
		size_t Up = 0, Dn = vecIn.size() - 1, Mid; // инициализация и объявление переменных
		do // цикл do while
		{
			Mid = (Up + Dn) / 2; // элемент по центру или чуть выше центра (если дробное число)
			if (vecIn[Mid].m_Nik[0] > ch1) // если имя по центру кодом больше символа по которому ищем
				Dn = Mid; // то смещаем нижнюю границу в центр
			else if (vecIn[Mid].m_Nik[0] < ch1) // если имя по центру меньше -||-
				Up = Mid; // то смещаем верхнюю границу в центр
			else if (vecIn[Mid].m_Nik[0] == ch1) // если имя по центру равно 
				return Mid; // то возвращаем это имя
			//exception
			if ((Dn - Up) == 1) // если границы стоят рядом друг с другом
			{
				if (vecIn[Up].m_Nik[0] == ch1) // Up = ch1?
					return Up; // ret Up
				if (vecIn[Dn].m_Nik[0] == ch1) // Dn = ch1?
					return Dn; // ret Dn
			}
		} while (Dn - Up > 1); // условие цикла do while
	}
	return -1;  // возвращение -1 если 
}