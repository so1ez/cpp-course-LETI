#include "stdafx.h" // стандартная библиотека
#include "FunMod.h" // написанная вручную библиотека
#include "string.h" // библиотека для работы со строками

int StrRepair(char* src, bool* er) // модуль обработки введенной строки
{
	char sOut[MY_STR_MAX_LEN]; // инициализация строки выхода (выходная строка), которую потом вернем
	bool znak = false; // инициализация булевской переменной, нужной для определения  наличия знака
	int j = 0; // инициализация необходимой переменной
	for (int i = 0; i < MY_STR_MAX_LEN && src[i]; i++) // цикл проверки строки на ошибки, и перенос найденного числа в строку выхода
	{
		if (((src[i] == '-') && (!znak)) || ((src[i] >= '0') && (src[i] <= '9') && (!znak))) // проверка на минус
		{
			sOut[0] = src[i]; // присваивание нулевому элементу выходной строки значение первой цифры входного числа
			znak = true; // присваивание переменной значение правда
			j++; // увеличение счетчика на единицу
			continue; // пропуск всего кода, написанного ниже, и переход к следующей итерации цикла for
		}
		if ((src[i] < '0') || (src[i] > '9')) // проверка на не цифры
		{
			*er = true; // присваивание переменной значение правда
			continue; // пропуск всего кода, написанного ниже, и переход к следующей итерации цикла for
		}
		sOut[j] = src[i]; // присваивание выходной строке соответствующее значение входной строки
		j++; // увеличение счетчика для выходной строки на единицу
	}
	sOut[j] = '\0'; // окончание выходной строки
	strcpy_s(src, MY_STR_MAX_LEN, sOut); // копирование значения выходной строки во входную

	return 0; // возвращение нуля
}

int Dec2BinStr(int val, char* ress) // модуль перевода число в двоичный код
{
	unsigned int mask = 1 << 31; // инициализация маски без знака
	int i = 0; // инициализация вспомогательного счетчика
	do // цикл do while для непосредственно перевода числа в двоичный код и запись его в строку-результат
	{
		if (val & mask) // если побитовое логическое И не ноль, то на месте единицы в маске стоит единица в введённом числе
			ress[i] = '1'; // вводим найденную единицу в строку-результат
		else ress[i] = '0'; // если побитовое логическое И всё-таки ноль, то вводим найденный ноль в строку-результат
		i++; // прибавляем к счетчику единицу
		mask = mask >> 1; // сдвигаем единицу в маске для определения последующих цифр в двоичном коде введённого числа
	} while (mask); // условие для окончания цикла do while
	ress[32] = '\0'; // обозначение конца строки
	return 0; // возвращение нуля
}

void MyStrTab(int n, int dep, char* bin, char* result, size_t resSize) // код нашей инициализированной функции
{
	if (n > 99) // условие, при котором функция работать не будет
		return; // выход из функции, если условие нарушено
	char TabTemp[] = "   |               |                                    "; // шаблон для вывода результатов = скелет таблицы
	char bufX[3]; // создание строки для первого столбца
	sprintf_s(bufX, "%d", n); // внесение результата в строку для первого столбца
	size_t pos = 2 - strlen(bufX); // инициализация позиции для замены на результат
	for (int i = 0; i < strlen(bufX); i++) // цикл замены шаблона (= скелета таблицы) на наши результаты
		TabTemp[pos + i] = bufX[i]; // сама замена

	char bufp[15]; // создание строки для второго столбца
	sprintf_s(bufp, "%d", dep); // внесение результата в строку для второго столбца
	pos = 19 - strlen(bufp); // инициализация позиции для замены на результат
	for (int i = 0; i < strlen(bufp); i++) // цикл замены шаблона (= скелета таблицы) на наши результаты
		TabTemp[pos + i] = bufp[i]; // сама замена

	char bufr[MY_STR_MAX_LEN]; // создание строки для третьего столбца
	sprintf_s(bufr, "%s", bin); // внесение результата в строку для третьего столбца
	pos = 52 - strlen(bufr); // инициализация позиции для замены на результат
	for (int i = 0; i < strlen(bufr); i++) // цикл замены шаблона (= скелета таблицы) на наши результаты
		TabTemp[pos + i] = bufr[i]; // сама замена

	strcpy_s(result, resSize, TabTemp); // замена выходных из функции данных на нашу строку таблицы

}